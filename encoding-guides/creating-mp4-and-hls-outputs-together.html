---
title: Guide de transmuxing
description: 'Cette rubrique explique le <strong>transmuxing</strong>, un processus qui vous permet d'encoder vos vidéos en MP4, puis de les reconditionner sous forme de sorties HLS.'
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Vue d'ensemble</h2>

    <p>Avec Zencoder, vous pouvez encoder vos vidéos en MP4, puis les reconditionner en tant que sorties HLS, via un processus que nous appelons "transmuxing" (plutôt que transcodage). Transmuxing reconditionnera les vidéos MP4 existantes dans les segments MPEG TS nécessaires pour la diffusion en direct HTTP (HLS), sans avoir à recoder les fichiers vidéo. À l'aide de sorties dépendantes, vous pouvez créer vos fichiers H.264 ainsi que les fichiers segmentés en une seule tâche, ce qui permet un délai d'exécution plus rapide à moindre coût ; les sorties transmuxées sont facturées au quart du coût de l'encodage. Le travail qui en résulte crée 6 sorties, dont 2 facturées au tarif normal de votre compte, 3 fichiers transmuxés au quart du coût d'encodage et 1 playlist gratuite.</p>

    <p>Pour cela, vous allez créer un seul travail avec deux ensembles principaux de sorties (plus les listes de lecture). Le premier ensemble de sorties sera des fichiers MP4 H.264/AAC normaux avec quelques paramètres spéciaux pour leur permettre de fonctionner comme fichiers source pour les sorties HLS. Le deuxième ensemble de sorties utilisera ces fichiers MP4 comme entrées "source", transmux leur contenu aux sorties HLS. Comme il s'agit de sorties dépendantes, elles attendront la fin de leur source correspondante avant d'être planifiées pour le traitement.</p>

    <p>L'élément clé du processus consiste à utiliser <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> une nouvelle option de la V2 de l'API Zencoder. La source indique à une sortie d'utiliser le fichier créé par une autre sortie du travail pour le traitement, au lieu du fichier d'entrée. Dans cette situation, Zencoder créera des fichiers H.264 basés sur le fichier d'entrée aux débits demandés. À la fin de chacune de ces sorties, une version segmentée sera alors créée à partir de la sortie.</p>

    <aside class="bcls-aside bcls-aside--information">Note : Il n'existe aucun moyen de garantir une lecture fluide si vous <strong>combiner les sorties transmux et transcodage en une seule liste de lecture</strong>. Il est recommandé que les rendus soient codés de la même manière.</aside>
  </section>
  <section class="bcls-section">
    <h2 id="h264_outputs">Les sorties H.264</h2>

    <p>Nous allons commencer par créer 2 fichiers H.264, en ciblant les débits élevés et faibles.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "label": "low",
    "format": "mp4",
    "video_bitrate": 200,
    "decoder_bitrate_cap": 300,
    "decoder_buffer_size": 1200,
    "audio_sample_rate": 44100,
    "height": "288",
    "url": "s3://example-bucket/low.mp4",
    "h264_reference_frames": 1,
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56,
    "decimate": 2
},
{
    "label": "high",
    "format": "mp4",
    "video_bitrate": 1000,
    "decoder_bitrate_cap": 1500,
    "decoder_buffer_size": 6000,
    "audio_sample_rate": 44100,
    "height": "432",
    "url": "s3://example-bucket/high.mp4",
    "h264_reference_frames": "auto",
    "h264_profile": "main",
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56
}</code></pre>

    <p>Les fichiers résultants de ces sorties peuvent être lus sur une grande variété d'appareils. Chacun cible un débit et une résolution différents, de sorte que les utilisateurs peuvent recevoir le fichier approprié. Chacun est également approprié pour la segmentation pour la diffusion en direct HTTP et sert de flux de débit adaptatif.</p>

    <p>Voici quelques options dans la demande ci-dessus pour noter :</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#forced-keyframe-rate"><code translate="No">forced_keyframe_rate</code></a> jusqu'à 0,1. Cela force la vidéo à avoir une image clé toutes les 10 secondes. Les fichiers segmentés dureront 10 secondes, ce qui garantit que chaque segment commencera par une image clé.</li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a> est défini sur 1,5 fois le débit binaire cible du fichier. <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a> est défini sur 3,5 x à 5 fois le débit binaire cible du fichier. Ces paramètres permettent de conserver un débit binaire cohérent dans tout le fichier, de sorte que les segments segmentés ne varient pas trop en taille et en débit.</li>
    </ul>
    <p>Maintenant que les fichiers H.264 ont été créés, des sorties supplémentaires peuvent être ajoutées à la demande de création de fichiers segmentés HTTP Live Streaming à partir de la source, sans avoir à effectuer d'encodage supplémentaire.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Segmented_Outputs">Sorties segmentées</h2>

    <p>Chacune des sorties vidéo H.264 et audio ci-dessus a <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#label"><code translate="No">labels</code></a> dans leurs options API. Ces étiquettes peuvent être utilisées avec le <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> option pour dire à Zencoder d'utiliser la vidéo créée par la sortie avec l'étiquette donnée, plutôt que le fichier d'entrée. Étant donné que les fichiers H.264 sont déjà avec de bons paramètres pour HLS, aucun encodage supplémentaire n'est nécessaire.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "source": "low",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-low/hls-low.m3u8",
    "label": "hls-low",
    "type": "segmented"
}
{
    "source": "high",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-high/hls-high.m3u8",
    "label": "hls-high",
    "type": "segmented"
}
{
    "streams": [
    {
        "path": "hls-low/hls-low.m3u8",
        "bandwidth": 256
    },
    {
        "path": "hls-high/hls-high.m3u8",
        "bandwidth": 1056
    }
    ],
    "type": "playlist",
    "url": "s3://example-bucket/playlist.m3u8"
}</code></pre>

    <p>Les fichiers résultants de ces sorties sont des sorties segmentées, ciblant différentes bandes passantes, plus un fichier de liste de lecture permettant au périphérique de lecture de connaître les flux disponibles.</p>

    <p>Chaque sortie segmentée inclut le <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a>, et spécifie l'une des sorties répertoriées précédemment. Ils comprennent également le <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a> et <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a> options, qui indiquent à Zencoder d'utiliser les flux audio et vidéo du fichier source et de les reconditionner dans le nouveau conteneur, plutôt que de les transcoder. Enfin, les sorties spécifient également un <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a> de segmenté et un <a href="/encoding-settings/formats-codecs/encoding-settings-format-and-codecs.html#format"><code translate="No">format</code></a> de ts, plus un <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#url"><code translate="No">url</code></a> avec une extension de .m3u8, pour que Zencoder sache créer des fichiers HLS segmentés.</p>

    <p>Enfin, il existe également une liste de lecture générée qui référence chacune des sorties segmentées. Notez que le premier fichier référencé dans la liste de lecture est la vidéo à faible débit binaire ; le périphérique qui joue la vidéo charge généralement le premier flux répertorié dans la liste de lecture initialement et bascule vers d'autres flux si nécessaire. Cela signifie que les 10 premières secondes de lecture utiliseront ce flux, après quoi l'appareil aura suffisamment d'informations pour sélectionner le flux approprié à lire.</p>

    <p><strong>NOTES</strong></p>

    <ul>
      <li>La génération de listes de lecture HLS n'utilise actuellement aucune information provenant des autres sorties du travail, mais est simplement un moyen de générer facilement une liste de lecture à débit adaptatif correctement formatée et de la télécharger avec les autres fichiers.</li>
      <li>Alors que les appareils iOS lisent la liste de lecture de débit adaptative créée, VLC ne le fera pas, en raison d'erreurs dans le traitement des URL relatives. Il recherchera les fichiers de segment dans le même répertoire que le fichier de liste de lecture, plutôt que le répertoire du fichier manifeste.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Full_request">Demande complète</h2>

    <p>Maintenant que nous avons passé en revue chacune des principales sections de sortie, rassemblons-les en une seule demande d'API.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "s3://zencodertesting/test.mov",
    "outputs": [
    {
        "label": "low",
        "format": "mp4",
        "video_bitrate": 200,
        "decoder_bitrate_cap": 300,
        "decoder_buffer_size": 1200,
        "audio_sample_rate": 44100,
        "height": "288",
        "url": "s3://example-bucket/low.mp4",
        "h264_reference_frames": 1,
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56,
        "decimate": 2
    },
    {
        "label": "high",
        "format": "mp4",
        "video_bitrate": 1000,
        "decoder_bitrate_cap": 1500,
        "decoder_buffer_size": 6000,
        "audio_sample_rate": 44100,
        "height": "432",
        "url": "s3://example-bucket/high.mp4",
        "h264_reference_frames": "auto",
        "h264_profile": "main",
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56
    },
    {
        "source": "low",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-low/hls-low.m3u8",
        "label": "hls-low",
        "type": "segmented"
    }
    {
        "source": "high",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-high/hls-high.m3u8",
        "label": "hls-high",
        "type": "segmented"
    }
    {
        "streams": [
        {
            "path": "hls-low/hls-low.m3u8",
            "bandwidth": 256
        },
        {
            "path": "hls-high/hls-high.m3u8",
            "bandwidth": 1056
        }
        ],
        "type": "playlist",
        "url": "s3://example-bucket/playlist.m3u8"
    }
    ]
}</code></pre>
  </section>
</article>
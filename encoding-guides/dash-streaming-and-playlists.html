---
title: Description du streaming et des listes de lecture DASH : Cette rubrique explique comment configurer des tâches pour la sortie DASH.
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Introduction">Introduction</h2>

    <aside class="bcls-aside bcls-aside--information">Notez que Dash n'est pas compatible avec les flux en direct utilisant Zencoder.</aside>
    <p>Étant donné que DASH n'est pas un format vidéo, un codec ou un format d'emballage indépendant des données (tel que Zip), nous avons introduit une nouvelle option nommée <a href="/encoding-settings/assets/encoding-settings-clips.html#streaming-delivery-format"><code translate="No">streaming_delivery_format</code></a>pour spécifier que les fichiers multimédias doivent être structurés / formatés selon une norme particulière. En sélectionnant "tiret" comme <code translate="No">streaming_delivery_format</code> modifiera certaines options par défaut pour la compatibilité avec DASH, et placera les fichiers multimédias de sortie dans une structure de répertoires conforme aux exigences de DASH. Les sorties multimédia DASH doivent également <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a> réglé sur "segmenté", pour garantir que le média est préparé pour la diffusion DASH.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd"
    }
    ]
}</code></pre>

    <p>Détails des sorties avec <code translate="No">streaming_delivery_format</code> défini sur "tiret":</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#fixed-keyframe-interval"><code translate="No">fixed_keyframe_interval</code></a> sera défini sur true.</li>
      <li><a href="/encoding-settings/assets/encoding-settings-clips.html#segment-seconds"><code translate="No">segment_seconds</code></a> sera par défaut à 2.</li>
      <li>Le format par défaut sera <code translate="No">m4f</code> (avec un <code translate="No">mpd</code> fichier manifeste)</li>
    </ul>
    <p>Structure de fichiers pour les sorties DASH segmentées :</p>

    <ul>
      <li>Le fichier <code translate="No">mpd</code> manifeste se trouve au niveau racine de la sortie.</li>
      <li>Les supports audio et vidéo auront chacun leur propre sous-répertoire, respectivement<code translate="No">audio/und</code>« » et<code translate="No">video/1</code>« ».</li>
      <li>Dans chacun de ces répertoires, il y aura un «<code translate="No">init.mp4</code>» avec les données d'initialisation.</li>
      <li>Les données multimédias seront dans des fichiers nommés<code translate="No">seg-N.m4f</code>" " (où N commence à zéro et augmente pour chaque segment).</li>
    </ul>
    <p>Les sorties DASH avec la <a href="/encoding-settings/assets/encoding-settings-clips.html#streaming-delivery-profile"><code translate="No">streaming_delivery_profile</code></a> valeur « on_demand » utilisent des fichiers multimédias fragmentés plutôt que des segments :</p>

    <ul>
      <li>Le fichier <code translate="No">mpd</code> manifeste se trouve au niveau racine de la sortie.</li>
      <li>Les médias audio et vidéo seront chacun un seul fichier dans le même répertoire que le manifeste.</li>
      <li>Les fichiers multimédias seront nommés de la même manière que le manifeste, mais avec "<code translate="No">-audio</code> " ou "<code translate="No">-video</code> " suffixes ajoutés, le cas échéant.</li>
    </ul>
    <p>Configurations DASH prises en charge :</p>

    <ul>
      <li>Formats pris en charge : <code translate="No">m4f</code> et <code translate="No">webm</code></li>
      <li>Codecs vidéo pris en charge : <code translate="No">h264</code> <code translate="No">hevc</code>, <code translate="No">vp8</code>, et <code translate="No">vp9</code></li>
      <li>Codecs audio pris en charge : <code translate="No">aac</code> <code translate="No">ac3</code>, <code translate="No">eac3</code>, et <code translate="No">vorbis</code></li>
      <li>Les sorties au format<code translate="No">webm</code>" " ne prennent actuellement en charge que l'option « on_demand » <code translate="No">streaming_delivery_profile</code></li>
      <li>Les sorties au format<code translate="No">webm</code>" " ne prennent actuellement pas en charge DRM</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Multiple_Bitrates">Débit binaire multiple</h2>

    <p>Les sorties DASH générées par Zencoder auront la structure nécessaire pour être jouées seules, mais pour vraiment bénéficier de ces options de diffusion en streaming, vous devez générer plusieurs versions à différents débits (rendus) ainsi qu'une sortie de type « playlist » qui répertorie les rendus de sorte qu'un lecteur peut commuter les débits binaires mont/bas au besoin en fonction des conditions actuelles du réseau. La sortie de la playlist est une sortie dépendante, c'est-à-dire qu'elle référencera les autres sorties par leur étiquette et utilisera les données de ces sorties pour générer le rendu final de la playlist. Notez que vous devez faire attention à définir les chemins de flux dans la sortie de la liste de lecture afin qu'ils soient des chemins relatifs à l'emplacement des fichiers de rendu.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "dash-1200",
        "streaming_delivery_format": "dash",
        "video_bitrate": 1200,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/1200k/rendition.mpd"
    },
    {
        "label": "dash-700",
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/700k/rendition.mpd"
    },
    {
        "label": "dash-400",
        "streaming_delivery_format": "dash",
        "video_bitrate": 400,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/400k/rendition.mpd"
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/dash-examples/mbr/manifest.mpd",
        "streams": [
        { "source": "dash-1200", "path": "1200k" },
        { "source": "dash-700",  "path": "700k" },
        { "source": "dash-400",  "path": "400k" }
        ]
    }
    ]
}</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Encryption">Cryptage</h2>

    <p>Zencoder prend également en charge la génération de sorties DASH cryptées CENC, avec les en-têtes nécessaires pour l'intégration avec les serveurs de licences Marlin ou Playready. Pour chaque sortie, il suffit de spécifier un hachage d'options DRM, y compris les options <a href="/encoding-settings/content-protection/encoding-settings-drm.html#method"><code translate="No">method</code></a>, <a href="/encoding-settings/content-protection/encoding-settings-drm.html#key-id"><code translate="No">key_id</code></a>, et <a href="/encoding-settings/content-protection/encoding-settings-drm.html#content-key"><code translate="No">content_key</code></a>. Le <code translate="No">key_id</code> et <code translate="No">content_key</code> doit être récupéré auprès de votre fournisseur DRM ou prégénéré et envoyé à votre fournisseur DRM. Une fois que vous avez ces clés, la structure de l'API Zencoder pour un rendu unique est la suivante :</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    }
    ]
}</code></pre>

    <p>Le contenu sera chiffré avec le <code translate="No">content_key</code>, et le fichier <code translate="No">.mpd</code> manifeste comprendra la <code translate="No">key_id</code> dans ses en-têtes. Cependant, pour garantir que cette sortie est jouable, il a également besoin d'en-têtes spécifiant comment récupérer le <code translate="No">content_key</code>. Sur un encodage DASH à plusieurs débits, ces en-têtes doivent seulement être ajoutés à la sortie de la playlist, mais peuvent également être ajoutés à chaque rendu, de sorte que le rendu soit individuellement lisible. Pour ce faire, ajoutez un ou plusieurs schémas DRM :</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/sbr/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
            { "type": "marlin" },
            { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}</code></pre>

    <p>Nous pouvons ensuite mettre cela en place pour créer une tâche DASH cryptée par DRM à plusieurs débits :</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "dash-1200",
        "streaming_delivery_format": "dash",
        "video_bitrate": 1200,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/1200k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-700",
        "streaming_delivery_format": "dash",
        "video_bitrate": 700,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/700k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-400",
        "streaming_delivery_format": "dash",
        "video_bitrate": 400,
        "type": "segmented",
        "url": "s3://mybucket/dash-examples/mbr/400k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/dash-examples/mbr/manifest.mpd",
        "streams": [
        { "source": "dash-1200", "path": "1200k" },
        { "source": "dash-700",  "path": "700k" },
        { "source": "dash-400",  "path": "400k" }
        ],
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
            { "type": "marlin" },
            { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}
</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Transmuxing">Transmultiplexage</h2>

    <p>Bien sûr, générer plusieurs formats d'une vidéo peut devenir coûteux et coûteux. Ainsi, Zencoder prend en charge le reconditionnement des mêmes flux encodés dans différents formats (appelé transmuxing), en utilisant le <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a> et <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a> options. Les sorties pour lesquelles la vidéo est transmux plutôt qu'encodée sont facturées à 1/4 de la durée normale. Donc, si vous prévoyez de créer plusieurs formats de la même vidéo (MP4, HLS et DASH, par exemple), vous pouvez d'abord encoder la version MP4 de chaque débit binaire, puis transmux ces sorties pour créer les versions HLS et DASH. (Notez que nous ne prenons pas en charge le transmuxage à partir d'un format segmenté, car la vidéo n'est plus un flux unique.)</p>

    <p>Pour vous assurer que le MP4 est préparé en fonction des contraintes des formats de streaming segmentés suivants, utilisez également l' <a href="/encoding-settings/assets/encoding-settings-clips.html#prepare-for-segmenting"><code translate="No">prepare_for_segmenting</code></a> option sur la sortie MP4. Cela contrôlera les valeurs par défaut des images clés et des légendes lors de l'encodage du flux vidéo du MP4 afin de garantir qu'il sera compatible avec le transmuxage vers des formats segmentés par la suite.</p>

    <p>L'utilisation du MP4 comme source pour les sorties transmuxées fonctionne de la même manière que les sorties de la playlist. Vous spécifiez une option source qui correspond à l'étiquette d'une autre sortie, mais cette fois, elle fait partie des options de niveau principal pour la sortie plutôt que dans le hachage des flux.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-700k",
        "prepare_for_segmenting": ["hls", "dash"],
        "video_bitrate": 700,
        "url": "s3://mybucket/transmux-examples/sbr/video.mp4"
    },
    {
        "source": "mp4-700k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/hls/video.m3u8"
    },
    {
        "source": "mp4-700k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/dash/video.mpd"
    }
    ]
}</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="Optimizing_for_delivery">Optimiser pour la livraison</h2>

    <p>Étant donné que DASH est destiné à la diffusion en continu, nous vous recommandons de contrôler les pics des débits binaires dans chaque rendu pour éviter que le joueur ne rebuffe ou passe inutilement à des codages à débit binaire inférieur. Les options qui contrôlent la variabilité du flux encodé en fonction de ce que le décodeur / lecteur peut gérer sont</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a></li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a></li>
    </ul>
    <aside class="bcls-aside bcls-aside--information">Remarque : <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#max-video-bitrate"><code translate="No">max_video_bitrate</code></a> permet de contrôler le débit binaire moyen maximal sur l'ensemble du flux et ne convient pas à une utilisation avec du contenu en streaming.</aside>
    <p>Notre recommandation générale est de <code translate="No">decoder_bitrate_cap</code> régler le débit maximum disponible pour le flux vidéo. N'oubliez pas que vous devez prendre en compte l'audio, ainsi qu'un peu de surcharge pour le format de fichier. Le <code translate="No">decoder_buffer_size</code> est techniquement supposé correspondre à la mémoire tampon vidéo disponible sur le périphérique de décodage, mais est souvent mieux utilisé pour contrôler la quantité de contenu qui peut être pré-tamponné. Il fonctionne comme un multiple de l' <code translate="No">decoder_bitrate_cap</code>, de sorte que, par exemple, il <code translate="No">decoder_bitrate_cap</code> était 500 (kilobits par seconde), et <code translate="No">decoder_buffer_size</code> était de 1000 (Kilobits), puis le tampon pouvait stocker 2 secondes de vidéo. Nous recommandons également de définir le paramètre <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#video-bitrate"><code translate="No">video_bitrate</code></a> un peu plus bas que le <code translate="No">decoder_bitrate_cap</code>, ce qui permet au codeur pour utiliser plus de données pour coder des scènes complexes et moins de données sur des scènes plus simples. Un point de départ décent serait de supposer jusqu'à 10 % des frais généraux pour le format de fichier, en définissant les <code translate="No">video_bitrate</code> 10 % inférieurs à la <code translate="No">decoder_bitrate_cap</code>, et en autorisant environ 1 0,5 seconde de vidéo à mettre en mémoire tampon.</p>

    <p>En supposant qu'une connexion de 1000 Kbps soit disponible pour le client :</p>

    <ul>
      <li>1000 * 0,90 = 900 Kbps disponible après soustraction de 10% pour les frais généraux de format.</li>
      <li>Vidéo 900 - 128 = 772 Kbps <code translate="No">decoder_bitrate_cap</code> après avoir soustrait 128 Kbps pour l'audio.</li>
      <li>772 * 1,5 = 1158 Ko <code translate="No">decoder_buffer_size</code> (pour 1,5 seconde de vidéo).</li>
      <li>772 * 0,90 = 695 Kbps débit binaire vidéo cible (10% inférieur au <code translate="No">decoder_bitrate_cap</code>).</li>
    </ul>
    <p>Par conséquent, pour un exemple de codage de streaming plus correct :</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-1000k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 772,
        "decoder_buffer_size": 1158,
        "video_bitrate": 695,
        "url": "s3://mybucket/transmux-examples/sbr/video.mp4"
    },
    {
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/hls/video.m3u8"
    },
    {
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/transmux-examples/sbr/dash/video.mpd"
    }
    ]
}</code></pre>

    <aside class="bcls-aside bcls-aside--information">Note : Ce qui précède est <strong>ne pas</strong> suffisant pour garantir que l'encodage HLS passerait la validation d'Apple. Alors qu'il serait diffusé de manière transparente sur une connexion de 1000 Kbps, Apple mesure les débits par segment (y compris le segment final qui peut avoir une courte durée), sans tenir compte des aspects de mise en mémoire tampon. Pour vous assurer que les codes HLS réussissent la validation d'Apple, consultez notre guide HLS.</aside>
  </section>
  <section class="bcls-section">
    <h2 id="Putting_it_all_together">Mettre tous ensemble</h2>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "http://s3.amazonaws.com/zencodertesting/test.mov",
    "outputs": [
    {
        "label": "mp4-1500k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 1222,
        "decoder_buffer_size": 1833,
        "video_bitrate": 1100,
        "size": "1280x720",
        "url": "s3://mybucket/full-examples/mp4/1500.mp4"
    },
    {
        "label": "mp4-1000k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 772,
        "decoder_buffer_size": 1158,
        "video_bitrate": 695,
        "size": "960x540",
        "url": "s3://mybucket/full-examples/mp4/1000.mp4"
    },
    {
        "label": "mp4-500k",
        "prepare_for_segmenting": ["hls", "dash"],
        "audio_bitrate": 128,
        "decoder_bitrate_cap": 322,
        "decoder_buffer_size": 483,
        "video_bitrate": 290,
        "size": "640x360",
        "url": "s3://mybucket/full-examples/mp4/500.mp4"
    },
    {
        "label": "hls-1500k",
        "source": "mp4-1500k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/1500.m3u8"
    },
    {
        "label": "hls-1000k",
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/1000.m3u8"
    },
    {
        "label": "hls-500k",
        "source": "mp4-500k",
        "copy_video": true,
        "copy_audio": true,
        "type": "segmented",
        "url": "s3://mybucket/full-examples/hls/500.m3u8"
    },
    {
        "type": "playlist",
        "url": "s3://mybucket/full-examples/hls/multi_bitrate_playlist.m3u8",
        "streams": [
        { "path": "1000.m3u8", "source": "hls-1000k" },
        { "path": "1500.m3u8", "source": "hls-1500k" },
        { "path": "500.m3u8", "source": "hls-500k" }
        ]
    },
    {
        "label": "dash-1500k",
        "source": "mp4-1500k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/1500k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-1000k",
        "source": "mp4-1000k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/1000k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "label": "dash-500k",
        "source": "mp4-500k",
        "copy_video": true,
        "copy_audio": true,
        "streaming_delivery_format": "dash",
        "type": "segmented",
        "url": "s3://mybucket/full-examples/dash/500k/rendition.mpd",
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0"
        }
    },
    {
        "streaming_delivery_format": "dash",
        "type": "playlist",
        "url": "s3://mybucket/full-examples/dash/manifest.mpd",
        "streams": [
            { "source": "dash-1500k", "path": "1500k" },
            { "source": "dash-1000k", "path": "1000k" },
            { "source": "dash-500k",  "path": "500k" }
        ],
        "drm": {
            "method": "cenc",
            "key_id": "d57d416ccd454d5a08d05bff0742ee76",
            "content_key": "f15cae8f4e48a023056e1960ff2228b0",
            "schemas": [
                { "type": "marlin" },
                { "type": "playready", "license_acquisition_url": "https://playready.example.com/license_server/" }
            ]
        }
    }
    ]
}</code></pre>
  </section>
</article>
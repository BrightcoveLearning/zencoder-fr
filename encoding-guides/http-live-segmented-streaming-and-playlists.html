---
title: Description du streaming et des listes de lecture HLS : La diffusion en direct HTTP facilite l'adaptation de votre flux vidéo ou audio à un utilisateur en fonction de sa bande passante disponible, en basculant entre les flux en cours de lecture à mesure que la vitesse de transfert change. Tirer toutes les pièces peut être déroutant, nous allons donc vous montrer comment créer quelques fichiers segmentés simples pour différentes bandes passantes et une liste de lecture à fournir aux utilisateurs sur les appareils iOS afin qu'ils puissent les lire.
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Segmented_Files">Fichiers segmentés</h2>

    <p>Nous allons commencer par créer plusieurs fichiers segmentés, chacun ciblant une bande passante donnée. Avec ces sorties, Zencoder crée un fichier manifeste et des fichiers vidéo segmentés, qui permettent au lecteur de télécharger chaque fichier individuellement pendant la lecture de la vidéo.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "audio_bitrate": 56,
    "audio_sample_rate": 22050,
    "base_url": "s3://my-bucket/",
    "decoder_bitrate_cap": 900,
    "decoder_buffer_size": 2400,
    "filename": "file-640k.m3u8",
    "max_frame_rate": 30,
    "public": 1,
    "type": "segmented",
    "video_bitrate": 600,
    "width": 400,
    "format": "ts"
}</code></pre>

    <p>Le <code translate="No">m3u8</code> fichier créé par la sortie ci-dessus est un fichier segmenté. La demande de cette sortie, ainsi que les autres décrites ci-dessous, créera plusieurs fichiers segmentés ciblés sur différentes bandes passantes.</p>

    <p>Cette sortie a un type de « segmenté », un format « ts » et est par défaut un codec vidéo de « h264 ». Chaque sortie segmentée aura un fichier manifeste au format M3U8 créé comme sortie principale, et les segments seront nommés comme le nom de fichier de la sortie. Les fichiers segmentés seront téléchargés à côté du manifeste et seront nommés avec les suffixes « -00001 » avant l'extension. Ces sorties peuvent être utilisées telles quelles pour le streaming standard, simplement en référençant le fichier .m3u8 du client et en veillant à ce que les fichiers de segment soient disponibles au même emplacement que le manifeste. Plusieurs fichiers .m3u8 peuvent également être référencés par une liste de lecture pour prendre en charge le streaming adaptatif.</p>
  </section>
  <section class="bcls-section">
    <h2 id="The_Playlist">La playlist</h2>

    <p>Vous pouvez créer vous-même des listes de lecture à débit adaptatif ou demander à Zencoder de le faire dans le cadre d'un travail. Pour nous faire créer la playlist, ajoutez simplement une autre sortie à votre travail avec un type de "playlist" et spécifiez un ou plusieurs flux avec un chemin (qui est relatif à l'emplacement du fichier de playlist) et la source du flux, qui est le étiquette de la sortie correspondante. La bande passante, la résolution et le codec peuvent également être spécifiés, mais par défaut, ils sont déduits de la source. Les informations de flux seront formatées dans une liste de lecture et téléchargées comme toute autre sortie.</p>

    <p>Ce fichier de liste de lecture fait référence aux sorties segmentées créées ci-dessus, en spécifiant la bande passante à laquelle chacune doit être lue. Le chargement de ce fichier avec un périphérique prenant en charge HLS permettra d'ajuster le flux en fonction des changements de bande passante disponible.</p>

    <p>La première entrée dans les flux sera utilisée lorsqu'un utilisateur ouvre le fichier et est utilisée dans le cadre d'un test pour déterminer quel flux est le plus approprié. L'ordre des autres entrées n'est pas pertinent.</p>

    <p>Sorties HLS (avec vidéo) qui ont <a href="/encoding-settings/general-audio-video/encoding-settings-segmented-streaming.html#max-hls-protocol-version">max_hls_protocol_version</a> de 4 ou plus générera désormais une liste de lecture I-Frame, également appelée "manifeste d'image clé". Par défaut, le nom de fichier est le même que le fichier manifeste principal, mais avec "-iframe-index" ajouté. Par exemple, pour un manifeste portant le nom de fichier « master.m3u8", le manifeste d'image-clé est nommé « master-iframe-index.m3u8 ». Cela peut être remplacé en utilisant <a href="/encoding-settings/general-audio-video/encoding-settings-segmented-streaming.html#keyframe-manifest-filename">keyframe_manifest_filename</a>. Si une sortie de liste de lecture HLS spécifie un flux « source » doté d'un manifeste d'image-clé, ce manifeste d'image-clé sera automatiquement inclus dans la liste de lecture en tant que flux EXT-X-I-FRAMES-ONLY.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "base_url": "s3://my-bucket/",
    "filename": "playlist.m3u8",
    "public": 1,
    "streams": [
    {
        "bandwidth": 440,
        "path": "file-440k.m3u8"
    },
    {
        "bandwidth": 640,
        "path": "file-640k.m3u8"
    },
    {
        "bandwidth": 240,
        "path": "file-240k.m3u8"
    },
    {
        "bandwidth": 150,
        "path": "file-150k.m3u8"
    },
    {
        "bandwidth": 64,
        "path": "file-64k.m3u8"
    }
    ],
    "type": "playlist"
}</code></pre>
  </section>
  <section class="bcls-section">
    <h2 id="The_Whole_Picture">L'image entière</h2>

    <p>Plusieurs sorties de différents débits binaires peuvent être spécifiées et référencées par la liste de lecture. Ces paramètres correspondent aux directives données dans notre <a href="/encoding-guides/iosmobile-encoding.html">Guide d'encodage iOS</a>.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "s3://zencodertesting/test.mov",
    "output": [
    {
        "label": "hls-64",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "filename": "file-64k.m3u8",
        "format": "aac",
        "public": 1,
        "type": "segmented"
    },
    {
        "label": "hls-240",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 300,
        "decoder_buffer_size": 800,
        "filename": "file-240k.m3u8",
        "max_frame_rate": 15,
        "public": 1,
        "type": "segmented",
        "video_bitrate": 200,
        "width": 400,
        "format": "ts"
    },
    {
        "label": "hls-440",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 600,
        "decoder_buffer_size": 1600,
        "filename": "file-440k.m3u8",
        "public": 1,
        "type": "segmented",
        "video_bitrate": 400,
        "width": 400,
        "format": "ts"
    },
    {
        "label": "hls-640",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 900,
        "decoder_buffer_size": 2400,
        "filename": "file-640k.m3u8",
        "public": 1,
        "type": "segmented",
        "video_bitrate": 600,
        "width": 480,
        "format": "ts"
    },
    {
        "label": "hls-1040",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 1500,
        "decoder_buffer_size": 4000,
        "filename": "file-1040k.m3u8",
        "public": 1,
        "type": "segmented",
        "video_bitrate": 1000,
        "width": 640,
        "format": "ts"
    },
    {
        "label": "hls-1540",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 2250,
        "decoder_buffer_size": 6000,
        "filename": "file-1540k.m3u8",
        "public": 1,
        "type": "segmented",
        "video_bitrate": 1500,
        "width": 960,
        "format": "ts"
    },
    {
        "label": "hls-2040",
        "audio_bitrate": 56,
        "audio_sample_rate": 22050,
        "base_url": "s3://my-bucket/",
        "decoder_bitrate_cap": 3000,
        "decoder_buffer_size": 8000,
        "filename": "file-2040k.m3u8",
        "public": 1,
        "type": "segmented",
        "video_bitrate": 2000,
        "width": 1024,
        "format": "ts"
    },
    {
        "base_url": "s3://my-bucket/",
        "filename": "playlist.m3u8",
        "public": 1,
        "streams": [
        {
            "source": "hls-2040",
            "path": "file-2040k.m3u8"
        },
        {
            "source": "hls-1540",
            "path": "file-1540k.m3u8"
        },
        {
            "source": "hls-1040",
            "path": "file-1040k.m3u8"
        },
        {
            "source": "hls-640",
            "path": "file-640k.m3u8"
        },
        {
            "source": "hls-440",
            "path": "file-440k.m3u8"
        },
        {
            "source": "hls-240",
            "path": "file-240k.m3u8"
        },
        {
            "source": "hls-64",
            "path": "file-64k.m3u8"
        }
        ],
        "type": "playlist"
    }
    ]
}</code></pre>

    <p><strong>NOTES</strong></p>

    <ul>
      <li>La génération de liste de lecture n'utilise actuellement aucune information des autres sorties du travail, mais est simplement un moyen de générer facilement une liste de lecture à débit adaptatif correctement formatée et de la télécharger avec les autres fichiers.</li>
      <li>Alors que les appareils iOS lisent la liste de lecture de débit adaptative créée, VLC ne le fera pas, en raison d'erreurs dans le traitement des URL relatives. Il recherchera les fichiers de segment dans le même répertoire que le fichier de liste de lecture, plutôt que le répertoire du fichier manifeste.</li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap">decoder_bitrate_cap</a> est défini sur 1,5 fois le débit binaire cible du fichier. <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size">decoder_buffer_size</a> est défini sur 3,5 x à 5 fois le débit binaire cible du fichier. Ces paramètres permettent de conserver un débit binaire cohérent dans tout le fichier, de sorte que les segments segmentés ne varient pas trop en taille et en débit.</li>
      <li>Si une sortie segmentée est téléchargée vers le stockage temporaire, elle sera téléchargée en tant que <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#package-format">Archive ZIP</a>.</li>
    </ul>
  </section>
</article>
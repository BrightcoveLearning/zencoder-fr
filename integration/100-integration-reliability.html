---
title: Fiabilité d'intégration à 100 %
description: 'Cette rubrique traite des raisons pour lesquelles vous ne pourrez peut-être pas vous connecter à Zencoder et comment garantir une intégration fiable.'
parent: Integration
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Vue d'ensemble</h2>

    <p>Zencoder est une dépendance logicielle essentielle pour la plupart de nos clients. Et même si nous visons une disponibilité de 100 %, il peut arriver que vous ne puissiez pas vous connecter à Zencoder :</p>

    <p>Lorsque cela se produit et que Zencoder est en panne, votre application recevra généralement une' réponse '503 Service Indisponible de Zencoder, mais vous pouvez obtenir une erreur différente (par exemple 500). Si vous avez dépassé la limite de débit de votre API, vous obtiendrez une' réponse 403 limite dépassée.</p>

    <p>Bonne nouvelle : puisque l'encodage vidéo est un processus asynchrone, vous pouvez créer votre application pour ne jamais rencontrer de temps d'arrêt ou de problèmes liés à notre disponibilité. Si vous faites cela, le pire des cas est que vos travaux prennent un peu plus de temps. Mais aucune erreur ne se produit. Nous vous recommandons vivement de le faire.</p>

    <p>Pour le dire plus clairement, <strong>si vous vous souciez de la fiabilité, vous devez suivre cette approche d'intégration</strong> - pour Zencoder ou pour toute API critique avec laquelle vous vous intégrez.</p>

    <ul>
      <li>Notre service peut être affecté par des problèmes chez un fournisseur en amont (par exemple, Amazon Web Services)</li>
      <li>Nous devons parfois effectuer une maintenance du système qui nécessite des temps d'arrêt temporaires</li>
      <li>Vous avez dépassé votre <a href="/general-information/faq-rate-limiting.html">Limite de débit API</a></li>
      <li>etc.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Reliable_app_integration">Intégration fiable des applications</h2>

    <ol>
      <li>Inclure un <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#secondary-url">URL secondaire</a> comme sauvegarde en cas d'échec du téléchargement vers votre emplacement principal.</li>
      <li>Si vous obtenez un code de réponse non réussi de Zencoder - en gros, autre chose qu'un 200 ou 201 - <strong>n'échouez pas le travail</strong>. Un code de réponse de 503 ne signifie pas que votre vidéo ne peut pas être traitée. Cela signifie simplement que Zencoder est temporairement indisponible.</li>
      <li>Si vous obtenez un <strong>erreur de connexion</strong> lorsque vous essayez de vous connecter à Zencoder, faites la même chose.</li>
      <li>De même, <strong>encapsulez vos requêtes API dans un délai d'expiration</strong>. Nous recommandons un délai d'attente de 30 secondes ; Zencoder répond généralement en moins d'une seconde, donc 30 secondes sont généralement suffisantes.</li>
      <li>Dans ces trois cas, si vous obtenez un code de réponse non réussi, si vous ne parvenez pas à vous connecter ou si la demande d'API est en attente, <strong>signalez la tâche comme étant « en attente ».</strong></li>
      <li>Périodiquement, <strong>soumettre à nouveau tous les travaux dans l'état 'en attente' </strong>. Vous pouvez utiliser cron pour faire cela toutes les minutes, par exemple.</li>
    </ol>
    <p>Une fois que les travaux sont soumis à nouveau, tout se comporte normalement. De cette façon, une soumission de travail échouée ne fait que prendre un peu plus de temps que de causer des problèmes à votre application ou à vos utilisateurs.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Pseudocode">Pseudocode</h2>

    <p>OK, donc ce n'est pas un pseudocode, c'est Ruby. Mais Ruby est assez facile à lire.</p>

    <ol>
      <li>Imaginez un tableau Vidéos qui inclut ces colonnes. (Il en aura évidemment plus, y compris des colonnes pour stocker un ID de travail Zencoder et un ID de fichier de sortie Zencoder.)
        <pre class="line-numbers">
<code class="language-ruby" translate="No">create_table :videos do |t|
t.string  :state
t.integer :lock_version
t.index   :state
end</code></pre>
      </li>
      <li>Une vidéo doit inclure une machine à états présentant les états suivants :
        <ul>
          <li>en attente (pas encore soumis à Zencoder)</li>
          <li>soumission (en cours de soumission à Zencoder)</li>
          <li>transcodage (soumis avec succès à Zencoder)</li>
          <li>terminé (Zencoder a terminé le transcodage et le travail est terminé)</li>
          <li>a échoué (Zencoder n'a pas pu transcoder la vidéo)</li>
        </ul>
      </li>
      <li>Lorsqu'une nouvelle vidéo est ingérée, enregistrez la vidéo dans l'' état de soumission et déclenchez une tâche en arrière-plan pour soumettre la vidéo à Zencoder.
        <pre class="line-numbers">
<code class="language-ruby" translate="No"># got a new video!
video = Video.new(params)
video.state = "submitting"
video.save!
submit_to_zencoder(video)</code></pre>

        <p>Vous devriez vraiment utiliser la méthode submit_to_zencoder en arrière-plan. Dans Ruby, en utilisant DelayedJob, cela peut ressembler à ceci :</p>

        <pre class="line-numbers">
<code class="language-ruby" translate="No">delay.submit_to_zencoder(video)</code></pre>

        <p>Mais nous allons rester avec notre <code translate="No">submit_to_zencoder(video)</code> méthode à des fins d'exemple.</p>
      </li>
      <li>La <code translate="No">submit_to_zencoder</code> fonction ressemble à ceci. Cela doit être exécuté de manière asynchrone, en arrière-plan.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def submit_to_zencoder(video)
begin
response = Zencoder::Job.create(attributes, :timeout =&gt; 30_000)
if response.code == 201
video.state = "transcoding"
else
video.state = "pending"
end

video.save!

# Rescue any connection error. Our plugin abstracts these as
# Zencoder::HTTPError.
#
# If you're not using the Zencoder plugin, this includes things
# like Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::ECONNREFUSED,
# Errno::EHOSTDOWN, and SocketError.

rescue Timeout::Error, Zencoder::HTTPError
video.state = "pending"
video.save!
end
end</code></pre>
      </li>
      <li>De temps en temps, par exemple toutes les minutes, essayez de renvoyer les travaux en' état « en attente ».
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def resubmit_pending_jobs
Video.where(:state =&gt; "pending").find_each do |video|
begin
video.state = "submitting"
video.save!

submit_to_zencoder(video)
rescue ActiveRecord::StaleObjectError
end
end
end
</code></pre>

        <p>En outre, en ajoutant une' colonne « lock_version » à la table des vidéos, nous introduisons un verrouillage optimiste. Cela signifie que si l'enregistrement est mis à jour entre la <code translate="No">Video.find</code> requête et <code translate="No">video.save</code>, il ne soumettra pas la tâche à Zencoder. Cela empêchera le travail d'être soumis à Zencoder deux fois par accident. Vous pouvez utiliser le verrouillage pessimiste ou de base de données ou une autre méthode de verrouillage pour accomplir la même chose.</p>

        <h2>C'est si facile…</h2>

        <p>Tout bien considéré, il s'agit d'une approche assez simple pour assurer une fiabilité d'intégration à 100% entre Zencoder et votre application. Il s'agit de quelques étapes supplémentaires que de simplement soumettre naïvement une tâche, mais cela garantit que peu importe ce qui se passe - qu'il s'agisse d'un délai d'expiration occasionnel, d'un temps d'arrêt inattendu chez Zencoder ou de maintenance planifiée, votre application fonctionne de manière fiable.</p>
      </li>
    </ol>
  </section>
</article>